module initialization_module
include("utils_module.jl")
using utils_module

using StaticArrays
using Printf

export microstate,SimulationParams, init_microstate,check_inputs, print_simulation_params

struct microstate # holds the variables of the actual current or proposed state
    N::Int # number of particles in the microstate
    λ::Int # coupling constant of the fractional particles
    r_box::Matrix{Float64}  # position of all N particles (3xN matrix)
    r_frac_box::MVector{3,Float64} # position of fractional particle
end

function load_configuration(filename::String)::Tuple{Int,Float64,Matrix{Float64}}
    # private function not exported
    # Loads in a cnf.inp file generated by Allen and Tildesly's initialize.py 
    # returns the first line, which has the number of particles in the configuration as N 
    # returns L_σ, the box length which is from the second line in lennard jones units
    # returns r_σ, the coordinates of the particles as a 3xN array in lennard jones units
#                       # r_N = [ x1  x2  x3 ... x_N
#                                 y1  y2  y3 ... y_N
#                                 z1  z2  z3 ... z_N ]
    # even though in the filename (e.g. cnf.inp) it is stored as an Nx3 array 
    open(filename, "r") do io
        # Read N (int)
        N = parse(Int, strip(readline(io)))

        # Read L (float)
        L_σ = parse(Float64, strip(readline(io)))

        # Read N lines of 3 floats each
        data = Array{Float64}(undef, N, 3)
        for i in 1:N
            data[i, :] = parse.(Float64, split(readline(io)))
        end

        # Transpose to 3×N (your preferred format)
        r_σ = permutedims(data)   # or data' gives 3×N Float64 matrix
        return N, L_σ, r_σ
    end
end # load_configuration(filename)

function init_microstate(;filename::String,λ::Int=0, r_frac_box::MArray{3,Float64}=MArray(0.0,0.0,0.0) )::microstate
    # initialize the microstate to feed into run_simulation() in segc_wl from input file
    N,L_σ,r_σ = load_configuration(filename)
    r_box = r_σ ./ L_σ # converting to "box units" by dividing the positions by the length of the box. Now r_i ∈ [-0.5,0.5]^3 because inputs are centered around 0,0
    r_box .= r_box .- round.(r_box) # periodic conditions, forces any atoms outside the box to wrap around and go back in
    μstate = microstate(N,λ,r_box,r_frac_box)
    return(μstate)
end # init microstate


struct SimulationParams
    # ~~~~~~~ Input parameters ~~~~~~~~~
    N_max::Int # maximum number of atoms in the simulation
    N_min::Int # minimum number of atoms in simulation
    T_σ::Float64 # temperature for Q(N,V,T,λ) in lennard jones units
    Λ_σ::Float64 # DeBroglie Wavelength for system, just passing in as somethign you compute instead of doing inside inner constructor for module loading dependency reasons

    λ_max::Int # maximum value lambda can take, equivalent of M-1 in desgranges et al because λ=100 is the same as λ=0
    r_cut_σ::Float64 # cutoff to stop evaluating LJ potential

    input_filename::String

    # ~~~~~~~ Derived parameters ~~~~~~~~~
    L_σ::Float64 # length of box in LJ units, read in from input file 
    V_σ::Float64 # volume
    L_squared_σ::Float64 # used to convert between box units (L_box=1) and LJ units
    r_cut_box::Float64
    r_cut_squared_box::Float64 # used for cutoff to avoid computing sqrts

    # Now using an "Inner Constructor" to compute the derived parameters from only the input ones
    function SimulationParams(; N_max,N_min,T_σ,Λ_σ,λ_max,r_cut_σ,input_filename) 
        # the semicolon above in (; N_max ... ) makes it so all these are keyword arguments, not positional ones so you set them with like 'N_max=100' when initializing a SimulationParams struct
        # Compute derived quantities
        _, L_σ, _  = load_configuration(input_filename)
        V_σ = L_σ^3
        L_squared_σ = L_σ^2
        r_cut_box = r_cut_σ/L_σ
        r_cut_squared_box = r_cut_box^2

        new(N_max,N_min,T_σ,Λ_σ,λ_max,r_cut_σ,input_filename,
            L_σ,V_σ,L_squared_σ,r_cut_box ,r_cut_squared_box)
    end
end # SimulationParams

function check_inputs(s::SimulationParams,µ::microstate)
    min_distance,particle_1,particle_2 = min_config_distance(μ.r_box)
    println("Minimum distance in box units (L_box=1) between particles in the initial configuration is: ",min_distance, " between particles ",particle_1, " and ", particle_2)
    println("This is compared to length of σ in box units which is: ", 1/L_σ)

    if μ.N != s.N_max
        throw(ArgumentError("Input mismatch: input config has $(μ.N) atoms but N_max is $(s.N_max), you want to start the simulation in the densest configuration"))
    end

end #check_inputs

function print_simulation_params(params::SimulationParams,start::Bool=true)
    println()
    if start
        println("           Starting SEGC Wang Landau Simulation        ")
        println("Due to the occurence of Λ in the metropolis criterion, this simulation cannot be fully carried out for lennard jonesium and is here specific to Argon")
    end
    @printf("T* = %.4f\n", params.T_σ)
    @printf("V = %.4f σ³\n", params.V_σ)
    @printf("Box Length L = %.4f σ\n", params.L_σ)
    @printf("DeBroglie Λ = %.4f σ\n", params.Λ_σ)
    
    @printf("Nmax = %d\n", params.N_max)
    @printf("Nmin = %d\n", params.N_min)
    @printf("λmax = %d\n", params.λ_max)

    @printf("r_cut = %.4f σ\n", params.r_cut_σ)

    println()
end #print_simulation_params

function print_microstate(μ::microstate,print_r::Bool=false)
    println()
    println("Current microstate:")
    @printf("N = %.4f\n", μ.N)
    @printf("λ = %.4f\n", μ.λ)
    if print_r 
        println("Positions of full particles in box units: ")
        display(μ.r_box)
        println()
        println("Position of fractional particle:")
        display(μ.r_frac_box)
    end
end #print_microstate
end 
