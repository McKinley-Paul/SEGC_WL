include("lj_module.jl")
using .LJ_Module

module UtilsModule
# This module contains stuff general to the monte carlo or wang landau process
export load_configuration, euclidean_distance, min_config_distance, euclidean_distance_squared_pbc, translate_by_random_vector, metropolis, λ_metropolis_pm1

function load_configuration(filename)
    # Loads in a cnf.inp file generated by Allen and Tildesly's initialize.py 
    # returns the first line, which has the number of particles in the configuration as N 
    # returns L, the box length which is from the second line 
    # returns r, the coordinates of the particles as a 3xN array:
#                       # r_N = [ x1  x2  x3 ... x_N
#                                 y1  y2  y3 ... y_N
#                                 z1  z2  z3 ... z_N ]
    # even though in the file cnf.inp it is stored as an Nx3 array 
    open(filename, "r") do io
        # Read N (int)
        N = parse(Int, strip(readline(io)))

        # Read L (float)
        L = parse(Float64, strip(readline(io)))

        # Read N lines of 3 floats each
        data = Array{Float64}(undef, N, 3)
        for i in 1:N
            data[i, :] = parse.(Float64, split(readline(io)))
        end

        # Transpose to 3×N (your preferred format)
        r = permutedims(data)   # or data' gives 3×N Float64 matrix
        return N, L, r
    end
end # load_configuration(filename)

function euclidean_distance(ri,rj)
    # computes the euclidean distance between ri and rj. chatgpt says doing this manually in this way is the fastest b/c it avoids allocations 
    # outputs r = √(Δx^2 +Δy^2 Δz^2 )
    Δx = ri[1]-rj[1]
    Δy = ri[2]-rj[2]
    Δz = ri[3]-rj[3]
    rij  = sqrt(Δx*Δx + Δy*Δy+ Δz*Δz)
    return(rij)
end # euclidean distance

function min_config_distance(r)
    # checks each pairwise distance in r and returns the minimum distance and the indices of the particles that that distance is between
    # so the user can identify if there is overlap or not. Needs to be called after renormalization to box units
    # and periodic boundary assurances are applied
    # assumes r is 3xN matrix, position of each atom stored as column vector

    m,N = size(r)
    @assert m==3 "position matrix doesn't seem to be 3xN"

    min_distance = typemax(Float64) # just initializing to be huge so don't have to add an extra condition to loop to check if it's the first time every time 
    i_min = 0
    j_min = 0
    @inbounds for i in 1:(N-1) # @inbounds tells the compiler to skip some safety checks it makes when doing loops involving arrays, basically we are telling the compiler we are not going to ask for an element not in the array bounds like r[0] or r[N+1] so it doesnt have to check for us, https://docs.julialang.org/en/v1/devdocs/boundscheck/
        ri = @view r[:,i]
        for j in (i+1):N
            rj = @view r[:,j] # no need to make a copy because we aren't modifying this at all 
            distance = euclidean_distance(ri,rj)
            if distance < min_distance
                min_distance = distance
                i_min = i 
                j_min = j 
            end
        end
    end # ij pair loop

    return(min_distance,i_min,j_min)
end #min_config_distance(r)

function euclidean_distance_squared_pbc(ri_box,rj_box)
    # computes the euclidean squared distance between ri and rj.  doing this manually in this way may be the fastest b/c it "avoids allocations" but im not sure
    # does so assuming ri and rj are in box units for periodic boundary conditions
    # outputs r2 = Δx^2 +Δy^2 Δz^2
    # avoids unneccesary sqrt for LJ potential which speeds things up
    Δx = ri_box[1]-rj_box[1]
    Δy = ri_box[2]-rj_box[2]
    Δz = ri_box[3]-rj_box[3]

    # now doing PBC in box=1 units
    Δx = Δx - round(Δx)
    Δy = Δy - round(Δy)
    Δz = Δz - round(Δz)

    rij_squared  = Δx*Δx + Δy*Δy+ Δz*Δz
    return(rij_squared)
end # euclidean distance squared


function translate_by_random_vector(r,δr_max)
    # returns a new vector translated by a random amount less than √3*(δr_max) in a random direction. Does not apply PBC
    # note that δr_max is the max that any x,y,z component can move
    ζ =  @MArray (rand(3)) #Three uniform random numbers in [0,1)
    ζ .= 2.0 .*ζ .- 1.0 # now in range [-1,+1]
    ζ .= ζ*δr_max       # now in range  [-δr_max,δr_max]
    r_new = r .+ ζ
    return(r_new)
end # translate_by_random_vector

function metropolis(ΔE,T_σ)
    # in the case of a translational move, the acceptance criteria reduces to the standard metropolis one. Assumes ΔE and T_σ have LJ units (both have energy units)
    exponent = -1*ΔE/T_σ 

    if exponent < -75 # energy difference is too great, just reject without evaluating
        return(false)
    elseif exponent > 0 # downhill, accept without evaluating due to min(1,e^exponent) and e^exponent > 1 if exponent > 0 
        return(true)
    else 
        ζ = rand() # random number between zero and 1
        accept = (exp(exponent) > ζ)   #boolean
        return(accept)
    end 

end # metropolis


function  λ_metropolis_pm1(λ,N,r_box,r_frac_box,
                        λ_proposed, N_proposed, r_proposed_box, r_frac_proposed_box,idx_deleted,
                        logQ_λN, Λ_σ,V_σ,T_σ,
                        λ_max,L_squared_σ,r_cut_squared_box)

        # MAKES SOME SIMPLIFYING ASSUMPTIONS THAT ONLY WORK WHEN LAMBDA CAN ONLY CHANGE BY ±1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # the purpose of the function is to handle the complex control flow based on the current value of λ and the proposed one.
        # many things change including the form of the metropolis criterion, what energies you have to compute to get ΔE, and so on.
        # covered by in general by equations 10-12 in Desgranges 2012
        # assumes that you have already checked that N_proposed is in bounds  (N_min ≤ N_proposed ≤ N_max)

        # first we compute the multiplicative prefactor term involving Q,V,Λ in eqns 10-12-- because the N! terms can cause overflow, we only compute them once we know something about N old vs new
        logQ_diff = logQ_λN[λ,N] - logQ_λN[λ_proposed,N_proposed]
        partition_ratio = exp(logQ_diff)
        if (λ > 0 && λ_proposed > 0) || (λ == 0 && λ_proposed == 0)
            V_Λ_prefactor = V_σ^(N_proposed-N) * Λ_σ^(3*N - 3*N_proposed)
        elseif λ ==0 && λ_proposed > 0
            V_Λ_prefactor = V_σ^(N_proposed+1-N) * Λ_σ^(3*N - 3(N_proposed+1))
        elseif λ > 0 && λ_proposed == 0 
            V_Λ_prefactor = V_σ^(N_proposed - N - 1) * Λ_σ^(3*(N+1)-3*N_proposed)
        end

        # now we compute the exponential part of the criterion having to do with the configurational potential energy

        if N==N_proposed # λ changed so change in configurational energy only has to do with fractional particle old vs new
            # following equation 10 desgranges
           E_old = potential_1_frac(r_box,r_frac_box,   λ   ,λ_max,N,L_squared_σ,r_cut_squared_box)
           E_proposed = potential_1_frac(r_box,r_frac_box,  λ_proposed  ,λ_max,N,L_squared_σ,r_cut_squared_box)
           factorial_prefactor = 1
        
        elseif N < N_proposed # particle created so λ = λ_max and λ_proposed = 0
            #  change in potential energy comes from fractional particle becoming full particle and the new fractional particle with λ=0 makes no contribution to energy
            # so E_Old = E_old_frac interaction with all others and E_new = E_new_full_particle interaction with all others
            factorial_prefactor = 1/N_proposed # only works for ±1
            E_old = potential_1_frac(r_box,r_frac_box,   λ   ,λ_max,N,L_squared_σ,r_cut_squared_box)
            i = size(r_proposed_box,2)
            E_proposed = potential_1_normal(r_proposed_box,@view r_proposed_box[:,end],i,r_frac_proposed_box,λ_proposed,λ_max,N_proposed,L_squared_σ,r_cut_squared_box)
                    
        elseif N > N_proposed # particle destroyed so λ = 0 and λ_proposed = 99
            # old energy is energy of destroyed particle with rest of full particles 
            # new configurational energy is interaction of fractional particle with others
            factorial_prefactor = N # only works for ±1
            E_old = potential_1_normal(r_box,@view r_box[:,idx_deleted],idx_deleted,r_frac_box,λ,λ_max,N,L_squared_σ,r_cut_squared_box)
            E_proposed = potential_1_frac(r_proposed_box,r_frac_proposed_box,   λ_proposed   ,λ_max,N_proposed,L_squared_σ,r_cut_squared_box)
        
        end # ΔN logic 

        ΔE = E_proposed - E_old
        exponent = -1*ΔE/T_σ 
        prob_ratio = partition_ratio*V_Λ_prefactor*factorial_prefactor*exp(exponent)
        if prob_ratio > 1
            return(true)
        else
            ζ = rand()
            accept = (prob_ratio > ζ)   #boolean
            return(accept)
        end
end #λ_metropolis_pm1


end # end UtilsModule